// Generated by CoffeeScript 2.3.2
(function() {
  var Interval, IntervalTree, Node, Point, SortedList, Util;

  SortedList = require('./sorted-list');

  Node = require('./node');

  Point = require('./point');

  Interval = require('./interval');

  Util = require('./util');

  /**
  interval tree

  @class IntervalTree
  @module interval-tree2
  */
  IntervalTree = class IntervalTree {
    /**
    @constructor
    @param {Number} center center of the root node
    */
    constructor(center1) {
      this.center = center1;
      Util.assertNumber(this.center, 'IntervalTree: center');
      /**
      center => node

      @property {Object(Node)} nodesByCenter
      */
      this.nodesByCenter = {};
      /**
      create root node
      */
      this.createNode(this.center);
    }

    /**
    add one interval

    @method add
    @public
    @param {Number} start start of the interval to create
    @param {Number} end   end of the interval to create
    @param {String|Number} [id] identifier to distinguish intervals. Automatically defiend when not set.
    @return {Interval}
    */
    add(start, end, id) {
      var interval;
      //if @intervalsById[id]?
      //    throw new Error('id ' + id + ' is already registered.')

      //if not id?
      //    while @intervalsById[@idCandidate]?
      //        @idCandidate++
      //    id = @idCandidate
      Util.assertNumber(start, '1st argument of IntervalTree#add()');
      Util.assertNumber(end, '2nd argument of IntervalTree#add()');
      if (start >= end) {
        Util.assertOrder(start, end, 'start', 'end');
      }
      interval = new Interval(start, end, id);
      
      // @pointTree.insert new Point(interval.start, id)
      // @pointTree.insert new Point(interval.end,   id)

      //@intervalsById[id] = JSON.stringify(interval)
      return this.insert(interval, this.center);
    }

    /**
    get intervals whose start position is less than or equal to the given value

    @method startPointSearch
    @param {Number} val
    @return {Array(Interval)}
    */
    startPointSearch(starts_sorted, val) {
      var index;
      index = starts_sorted.lastPositionOf({
        start: val
      });
      return starts_sorted.slice(0, index + 1);
    }

    /**
    get intervals whose end position is more than or equal to the given value

    @method endPointSearch
    @param {Number} val
    @return {Array(Interval)}
    */
    endPointSearch(ends_sorted, val) {
      var index;
      index = ends_sorted.firstPositionOf({
        end: val
      });
      return ends_sorted.slice(index);
    }

    /**
    search intervals at the given node

    @method pointSearch
    @public
    @param {Number} val
    @param {Node} [node] current node to search. default is this.root
    @return {Array(Interval)}
    */
    pointSearch(val, center = this.center, results = []) {
      var ends_sorted, node, starts_sorted;
      node = JSON.parse(this.nodesByCenter[center]);
      Util.assertNumber(val, '1st argument of IntervalTree#pointSearch()');
      if (val < node.center) {
        starts_sorted = this.create_list(node.starts, 'start');
        results = results.concat(this.startPointSearch(starts_sorted, val));
        if (node.left != null) {
          return this.pointSearch(val, node.left, results);
        } else {
          return results;
        }
      }
      if (val > node.center) {
        ends_sorted = this.create_list(node.ends, 'end');
        results = results.concat(this.endPointSearch(ends_sorted, val));
        if (node.right != null) {
          return this.pointSearch(val, node.right, results);
        } else {
          return results;
        }
      }
      // if val is node.center
      return results.concat(node.getAllIntervals());
    }

    /**
    create Sorted List from elements
     @method create_list
     @private
     @param {List} elems
     @param {String} type of val
     @return {SortedList} created sorted list
    */
    create_list(elems, val) {
      var elem, i, len, nlist;
      nlist = new SortedList(val);
      for (i = 0, len = elems.length; i < len; i++) {
        elem = elems[i];
        nlist.insert(elem);
      }
      return nlist;
    }

    /**
    insert interval to the given node

    @method insert
    @private
    @param {Interval} interval
    @param {Node} node node to insert the interval
    @return {Interval} inserted interval
    */
    insert(interval, center) {
      var ends_sorted, left_node, node, right_node, starts_sorted;
      node = JSON.parse(this.nodesByCenter[center]);
      if (interval.end < node.center) {
        if (node.left == null) {
          left_node = this.createNode(interval.end);
          node.left = left_node.center;
          this.nodesByCenter[center] = JSON.stringify(node);
        }
        //node.left ?= @createNode(interval.end)
        return this.insert(interval, node.left);
      }
      if (node.center < interval.start) {
        if (node.right == null) {
          right_node = this.createNode(interval.start);
          node.right = right_node.center;
          this.nodesByCenter[center] = JSON.stringify(node);
        }
        return this.insert(interval, node.right);
      }
      starts_sorted = this.create_list(node.starts, 'start');
      //ends_sorted = this.create_list(node.ends, 'end');
      starts_sorted.insert(interval);
      //ends_sorted.insert(interval);
      node.starts = starts_sorted;
      //node.ends = ends_sorted;
      this.nodesByCenter[center] = JSON.stringify(node);
      return interval;
    }

    /**
    create node by center

    @method createNode
    @private
    @param {Number} center
    @return {Node} node
    */
    createNode(center) {
      var node;
      node = new Node(center);
      this.nodesByCenter[center] = JSON.stringify(node);
      return node;
    }

  };

  module.exports = IntervalTree;

}).call(this);
