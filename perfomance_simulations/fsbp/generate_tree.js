// Generated by CoffeeScript 2.3.2
(function() {
  var NgramProb, RangeTree, fs, ngram_prob, readline, zlib,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  fs = require('fs');

  zlib = require('zlib');
  crypto = require('crypto');
  converter = require('hex2dec');
  readline = require('readline');

  NgramProb = require('/home/bijeeta/cloudfare/pwmodels/src/ngram_cs/ngram-prob');
  filename = 'res.json';
  ngram_prob = new NgramProb(filename);

  RangeTree = class RangeTree {
    constructor(index) {
      this.store_json = this.store_json.bind(this);
      this.bucket_size = 2 ** 30;
      this.lineReader = readline.createInterface({
        input: fs.createReadStream('/hdd/c3s/data/aws_data/splits/pass_list0'+index)
      });
      this.writer = fs.createWriteStream('/hdd/c3s/data/aws_data/splits/ps_range_1000_2-30_'+index+'.txt', {
        flags: 'a'
      });
    }

    trim(s) {
      return (s || '').replace(/^\s+|\s+$/g, '');
    }

    get_range(pw) {
      var dec, hash, hex, min_gamma, prob_bucktes, prob_pq, prob_pw, res;
      prob_pw = ngram_prob.cal_prob(pw);
      
      prob_pq = ngram_prob.cal_prob_topq(100);
      prob_bucktes = Math.ceil((this.bucket_size * prob_pw) / prob_pq);
      min_gamma = Math.min(this.bucket_size, prob_bucktes);
      hash = crypto.createHash('sha1');
      hash.update(pw);
      hex = hash.digest('hex');
      dec = converter.hexToDec(hex.substring(0, 10));
      res = [];
      res.push(modulo(dec, this.bucket_size));
      res.push((modulo(dec, this.bucket_size)) + min_gamma);
      res.push(modulo(dec, 10));
      return res;
    }

    store_json() {
      var i, startTime;
      i = 0;
      startTime = new Date();
      this.lineReader.on('line', (line) => {
        var data, data_toWrite, endTime, timeDiff, word;
        if (i % 10000 === 0) {
          endTime = new Date();
          timeDiff = endTime - startTime;
          timeDiff /= 1000;
          console.log(timeDiff);
          console.log(i);
        }
        word = this.trim(line.toString());
        data = this.get_range(word);
        data_toWrite = word.concat("\t").concat(data[0]).concat("\t").concat(data[1]).concat("\t").concat(data[2]).concat("\n");
        this.writer.write(data_toWrite);
        return i = i + 1;
      });
      return this.lineReader.on('close', () => {
        var endTime, timeDiff;
        endTime = new Date();
        timeDiff = endTime - startTime;
        timeDiff /= 1000;
        console.log(timeDiff);
        return console.log("done");
      });
    }

  };

  module.exports = RangeTree;

}).call(this);
