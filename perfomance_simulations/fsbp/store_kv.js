// Generated by CoffeeScript 2.3.2
(function() {

  /**
  get intervals whose end position is more than or equal to the given value

  @method endPointSearch
  @param {Number} val
  @return {Array(Interval)}
  */
  var IntervalTree, KeyValueStore, SortedList, Util, create_list, elem, endPointSearch, fs, get_passwords, itree, kv, onlyUnique, pointSearch, pw_range, pw_tree, rawdata, ref, startPointSearch, total, v, val;

  ({KeyValueStore} = require('../lib/kv'));

  fs = require('fs');

  Util = require('/home/bijeeta/cloudfare/code_c3s/cloudworker/c3s/interval_tree/lib_js/util');

  SortedList = require('/home/bijeeta/cloudfare/code_c3s/cloudworker/c3s/interval_tree/lib_js/sorted-list');

  kv = new KeyValueStore();

  IntervalTree = require('/home/bijeeta/cloudfare/code_c3s/cloudworker/c3s/interval_tree/lib_js/interval-tree');

  itree = new IntervalTree(2 ** 40);

  rawdata = fs.readFileSync('/hdd/c3s/data/aws_data/breach_compilation-pw_range.json');

  pw_range = JSON.parse(rawdata);

  for (elem in pw_range) {
    val = pw_range[elem];
    if (val[0] === val[1]) {
      continue;
    }
    itree.add(val[0], val[1], elem);
  }

  total = 0;

  ref = itree.nodesByCenter;
  for (elem in ref) {
    v = ref[elem];
    total = total + 1;
    kv.put(elem, v);
  }

  console.log(total);

  pw_tree = JSON.stringify(itree.nodesByCenter);

  fs.writeFileSync('/hdd/c3s/data/aws_data/breach_compilation-pw_tree_1000000.json', pw_tree);

  startPointSearch = function(starts_sorted, val) {
    var index;
    index = starts_sorted.lastPositionOf({
      start: val
    });
    return starts_sorted.slice(0, index + 1);
  };

  endPointSearch = function(ends_sorted, val) {
    var index;
    index = ends_sorted.firstPositionOf({
      end: val
    });
    return ends_sorted.slice(index);
  };

  create_list = function(elems, val) {
    var i, len, nlist;
    nlist = new SortedList(val);
    for (i = 0, len = elems.length; i < len; i++) {
      elem = elems[i];
      nlist.insert(elem);
    }
    return nlist;
  };

  pointSearch = async function(val, center = this.center, results = []) {
    var ends_sorted, node, starts_sorted, word;
    word = (await kv.get(`${center}`, 'text'));
    node = JSON.parse(word);
    Util.assertNumber(val, '1st argument of IntervalTree#pointSearch()');
    if (val < node.center) {
      starts_sorted = create_list(node.starts, 'start');
      results = results.concat(startPointSearch(starts_sorted, val));
      if (node.left != null) {
        return pointSearch(val, node.left, results);
      } else {
        return results;
      }
    }
    if (val > node.center) {
      ends_sorted = create_list(node.ends, 'end');
      results = results.concat(endPointSearch(ends_sorted, val));
      if (node.right != null) {
        return pointSearch(val, node.right, results);
      } else {
        return results;
      }
    }
    
    // if val is node.center
    return results.concat(node.getAllIntervals());
  };

  onlyUnique = function(value, index, self) {
    return self.indexOf(value) === index;
  };

  get_passwords = async function(val) {
    var i, interval, intervals, j, len, len1, passwords;
    intervals = (await pointSearch(val, 2 ** 40));
    passwords = [];
    for (i = 0, len = intervals.length; i < len; i++) {
      interval = intervals[i];
      passwords.push(interval.id);
    }
    intervals = (await pointSearch(val + 2 ** 40, 2 ** 41));
    for (j = 0, len1 = intervals.length; j < len1; j++) {
      interval = intervals[j];
      passwords.push(interval.id);
    }
    console.log(passwords);
    return passwords.filter(onlyUnique);
  };

  
//passwords = get_passwords(943328285131)

}).call(this);
